"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractTypes = extractTypes;

var _typesCreate = require("@polkadot/types-create");

// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
function extractSubSingle(_ref) {
  let {
    lookupName,
    type
  } = _ref;
  return extractTypes([lookupName || type]);
}

function extractSubArray(types) {
  return extractTypes(types.map(_ref2 => {
    let {
      lookupName,
      type
    } = _ref2;
    return lookupName || type;
  }));
}
/** @internal */


function extractTypes(types) {
  return types.map(type => {
    const decoded = (0, _typesCreate.getTypeDef)(type);

    switch (decoded.info) {
      case _typesCreate.TypeDefInfo.Plain:
        return decoded.lookupName || decoded.type;

      case _typesCreate.TypeDefInfo.BTreeSet:
      case _typesCreate.TypeDefInfo.Compact:
      case _typesCreate.TypeDefInfo.Option:
      case _typesCreate.TypeDefInfo.Vec:
      case _typesCreate.TypeDefInfo.VecFixed:
      case _typesCreate.TypeDefInfo.WrapperKeepOpaque:
      case _typesCreate.TypeDefInfo.WrapperOpaque:
        return extractSubSingle(decoded.sub);

      case _typesCreate.TypeDefInfo.BTreeMap:
      case _typesCreate.TypeDefInfo.Enum:
      case _typesCreate.TypeDefInfo.HashMap:
      case _typesCreate.TypeDefInfo.Result:
      case _typesCreate.TypeDefInfo.Set:
      case _typesCreate.TypeDefInfo.Struct:
      case _typesCreate.TypeDefInfo.Tuple:
        return extractSubArray(decoded.sub);

      default:
        throw new Error(`Unhandled: Unable to create and validate type from ${type} (info=${_typesCreate.TypeDefInfo[decoded.info]})`);
    }
  });
}