import type { Codec, CodecClass, CodecRegistry, ICompact, INumber } from '@polkadot/types-codec/types';
export type { CodecCreateOptions as CreateOptions } from '@polkadot/types-codec/types';
export declare enum TypeDefInfo {
    BTreeMap = 0,
    BTreeSet = 1,
    Compact = 2,
    DoNotConstruct = 3,
    Enum = 4,
    HashMap = 5,
    Int = 6,
    Linkage = 7,
    Null = 8,
    Option = 9,
    Plain = 10,
    Range = 11,
    Result = 12,
    Set = 13,
    Si = 14,
    Struct = 15,
    Tuple = 16,
    UInt = 17,
    Vec = 18,
    VecFixed = 19,
    WrapperKeepOpaque = 20,
    WrapperOpaque = 21
}
export interface TypeDef {
    alias?: Map<string, string>;
    displayName?: string;
    docs?: string[];
    fallbackType?: string;
    info: TypeDefInfo;
    index?: number;
    isFromSi?: boolean;
    length?: number;
    lookupIndex?: number;
    lookupName?: string;
    lookupNameRoot?: string;
    name?: string;
    namespace?: string;
    sub?: TypeDef | TypeDef[];
    type: string;
    typeName?: string;
}
export interface ILookup {
    getSiType(lookupId: ICompact<INumber> | string | number): {
        def: {
            asTuple: ICompact<INumber>[];
        };
    };
    getTypeDef(lookupId: ICompact<INumber> | string | number): TypeDef;
}
export interface CreateRegistry extends CodecRegistry {
    lookup: ILookup;
    createLookupType(lookupId: ICompact<INumber> | number): string;
    setLookup(lookup: ILookup): void;
    getUnsafe<T extends Codec = Codec, K extends string = string>(name: K, withUnknown?: boolean, knownTypeDef?: TypeDef): CodecClass<T> | undefined;
}
